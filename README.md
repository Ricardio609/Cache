# Cache

goCache

1. 缓存数据结构  lru
2. 单机并发缓存
3. HTTP服务端
4. 一致性哈希（consistent hashing)

* consistent hashing 是从单节点走向分布式的一个重要环节(对于给定的key, 每一次都选择同一个节点）

  * 节点数量固定时，当一个节点收到请求时，如果该节点并没有存储缓存值，利用自定义的hash算法来实现将某些查找分配给固定的节点，避免：1）缓存效率低；2）各个节点上存储着相同的数据，浪费大量的存储空间。
  * 节点数量发生变化时，意味着几乎缓存值对应的节点都发生了改变（即几乎所有的缓存值都失效了），节点在接收到对应的请求时，均需要重新取数据源取数据，容易引起`缓存雪崩`。
    * `缓存雪崩`：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。长因为缓存服务器宕机，或缓存设置了相同的过期时间引起。
* consistent hashing算法原理

  * 将key映射到2^32的空间中，并将这个数字首尾相连，形成一个环，如下图。
    * 计算节点/机器（通常使用节点的名称、编号和IP地址）的哈希值，放置在环上
    * 计算key的哈希值，放置在环上，顺时针找到的第一个节点，就是应选取的节点/机器

![](https://geektutu.com/post/geecache-day4/add_peer.jpg)

* 该算法在新增/删除节点时，只需要重新定位该节点附件的一小部分数据，而不需要重新定位所有的节点。
* 该算法存在`数据倾斜`的问题
  * 如果服务器的节点过少，则容易引发key的倾斜。例如上面的图片中，peeer2、4、6分布在环的上半部分，下部分是空的，这就导致映射到下半部分的key都会被分配给peer2，key过度向peer2倾斜，缓存节点负载不均。
  * 针对该问题，引入虚拟节点（一个真实节点对应多个虚拟节点）

    * 示例：假设1个真实节点对应3个虚拟节点，那么peer1对应的虚拟节点是peer1-1、peer1-2、peer1-3（通常以添加编号的方式实现），其余节点也以相同的方式操作
    * 第一步：计算虚拟节点的hash值，放置在环上
    * 第二部：计算key的hash值，在环上顺时针寻找应选去的虚拟节点，例如是peer2-1，那么就对应着真实节点peer2
  * 引入虚拟节点的优势：虚拟节点扩充了节点的数量，解决了节点数量较少的情况下数据容易倾斜的问题。代价非常小，只需要增加一个字典(map)维护真实节点与虚拟节点的映射关系即可
